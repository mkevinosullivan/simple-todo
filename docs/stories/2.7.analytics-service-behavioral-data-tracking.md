# Story 2.7: Analytics Service for Behavioral Data Tracking

## Status

Done

## Story

**As a** developer, **I want** an AnalyticsService that captures and calculates behavioral metrics, **so that** we have data insights available for future features and can validate MVP success criteria.

## Acceptance Criteria

1. AnalyticsService class created with methods: `getCompletionRate()`, `getAverageTaskLifetime()`, `getTaskCountByStatus()`, `getOldestActiveTask()`
2. `getCompletionRate()` calculates (tasks completed / total tasks created) × 100, returns percentage
3. `getAverageTaskLifetime()` calculates mean lifetimeDuration for completed tasks, returns milliseconds
4. `getTaskCountByStatus()` returns object: `{ active: number, completed: number }`
5. `getOldestActiveTask()` finds active task with earliest createdAt timestamp, useful for age indicators
6. Service reads data from DataService/TaskService (no separate analytics storage for MVP)
7. Calculations handle edge cases: division by zero (no completed tasks), empty task list
8. Analytics calculated on-demand (not cached) for MVP simplicity - acceptable performance for <10k tasks
9. Unit tests verify calculations with various task datasets: all active, all completed, mixed states, empty
10. Service provides foundation for Phase 2 visual trend dashboard without needing refactoring

## Tasks / Subtasks

- [x] **Create AnalyticsService class with core structure** (AC: 1, 6)
  - [x] Create file `apps\server\src\services\AnalyticsService.ts`
  - [x] Import TaskService for data access
  - [x] Define class with constructor accepting TaskService dependency
  - [x] Add JSDoc comments explaining service purpose and design decisions
  - [x] Follow singleton service pattern (instantiate once, share across requests)

- [x] **Implement getCompletionRate() method** (AC: 2, 7)
  - [x] Add method signature: `getCompletionRate(): Promise<number>`
  - [x] Fetch all tasks via TaskService
  - [x] Count total tasks created (all tasks regardless of status)
  - [x] Count completed tasks (status === 'completed')
  - [x] Calculate: (completed / total) × 100
  - [x] Handle edge case: return 0 when total tasks is 0 (avoid division by zero)
  - [x] Return percentage as number (0-100)
  - [x] Add JSDoc with calculation formula and edge case handling

- [x] **Implement getAverageTaskLifetime() method** (AC: 3, 7)
  - [x] Add method signature: `getAverageTaskLifetime(): Promise<number | null>`
  - [x] Fetch all tasks via TaskService
  - [x] Filter to only completed tasks (status === 'completed')
  - [x] Use TaskHelpers.getDuration(createdAt, completedAt) for each completed task
  - [x] Calculate mean: sum of all durations / count of completed tasks
  - [x] Handle edge case: return null when no completed tasks exist
  - [x] Return average duration in milliseconds
  - [x] Add JSDoc documenting use of TaskHelpers and null return case

- [x] **Implement getTaskCountByStatus() method** (AC: 4)
  - [x] Add method signature: `getTaskCountByStatus(): Promise<{ active: number; completed: number }>`
  - [x] Fetch all tasks via TaskService
  - [x] Count tasks where status === 'active'
  - [x] Count tasks where status === 'completed'
  - [x] Return object with both counts
  - [x] Handle empty task list (both counts return 0)
  - [x] Add JSDoc documenting return structure

- [x] **Implement getOldestActiveTask() method** (AC: 5, 7)
  - [x] Add method signature: `getOldestActiveTask(): Promise<Task | null>`
  - [x] Fetch all tasks via TaskService
  - [x] Filter to only active tasks (status === 'active')
  - [x] Find task with earliest createdAt timestamp (sort by createdAt ascending)
  - [x] Handle edge case: return null when no active tasks exist
  - [x] Return the oldest Task object or null
  - [x] Add JSDoc explaining use case for age indicators

- [x] **Export AnalyticsService and wire into application** (AC: 1)
  - [x] Export AnalyticsService class from the module
  - [x] Follow existing service patterns (see WIPLimitService, TaskService for examples)
  - [x] Do NOT create API routes yet (deferred to Phase 2 per PRD)
  - [x] Service should be ready for future API integration

- [x] **Write comprehensive unit tests** (AC: 9)
  - [x] Create file `apps\server\tests\unit\services\AnalyticsService.test.ts`
  - [x] Set up test suite with mocked TaskService dependency
  - [x] Test getCompletionRate():
    - [x] Returns 0 when no tasks exist (empty list)
    - [x] Returns 0 when total tasks > 0 but no completed tasks
    - [x] Returns 100 when all tasks completed
    - [x] Returns correct percentage for mixed dataset (e.g., 3 completed out of 7 total = 42.857...)
  - [x] Test getAverageTaskLifetime():
    - [x] Returns null when no tasks exist
    - [x] Returns null when no completed tasks (all active)
    - [x] Returns correct average for single completed task
    - [x] Returns correct average for multiple completed tasks with varying durations
  - [x] Test getTaskCountByStatus():
    - [x] Returns {active: 0, completed: 0} when no tasks
    - [x] Returns correct counts for all active tasks
    - [x] Returns correct counts for all completed tasks
    - [x] Returns correct counts for mixed dataset
  - [x] Test getOldestActiveTask():
    - [x] Returns null when no tasks exist
    - [x] Returns null when all tasks are completed (no active)
    - [x] Returns oldest task when multiple active tasks exist
    - [x] Returns correct task when only one active task
  - [x] Run tests: `npm run test:server -- AnalyticsService.test.ts`
  - [x] Verify 70%+ code coverage for AnalyticsService

## Dev Notes

### Architectural Context

This story implements the **AnalyticsService** as a foundational data analysis layer. The service calculates behavioral metrics on-demand from existing task data without requiring additional storage or caching infrastructure for the MVP. [Source: Epic 2, Story 2.7]

**Design Pattern:** Service Layer Pattern - Business logic encapsulated in services (TaskService, WIPLimitService, etc.) for separation of concerns, unit testability, and reusability across API endpoints. [Source: architecture/2-high-level-architecture/architectural-patterns.md#Backend Patterns]

**Singleton Services:** Services are instantiated once and shared across requests. The localhost single-user app has no concurrency concerns, simplifying architecture. [Source: architecture/2-high-level-architecture/architectural-patterns.md#Backend Patterns]

### Data Models & Computed Properties

**AnalyticsData Interface** [Source: architecture/4-data-models.md#AnalyticsData]:
```typescript
export interface AnalyticsData {
  completionRate: number;              // Percentage (0-100)
  averageTaskLifetime: number;         // Milliseconds (computed using TaskHelpers.getDuration)
  taskCountByStatus: {
    active: number;
    completed: number;
  };
  oldestActiveTask: Task | null;       // For age indicators
}
```

**Task Interface** [Source: architecture/4-data-models.md#Task]:
```typescript
export interface Task {
  id: string;                          // UUID
  text: string;                        // 1-500 characters
  status: TaskStatus;                  // 'active' | 'completed'
  createdAt: string;                   // ISO 8601 timestamp
  completedAt: string | null;          // ISO 8601 timestamp or null if active
}
```

**TaskHelpers Utilities** [Source: architecture/4-data-models.md#Task, Story 2.1]:
The AnalyticsService MUST use existing TaskHelpers for duration calculations:

```typescript
import { TaskHelpers } from '@simple-todo/shared/utils';

// Calculate task lifetime duration (creation to completion)
const duration = TaskHelpers.getDuration(task.createdAt, task.completedAt);
// Returns: number (milliseconds) | null (if task not completed)
```

**Key Point:** TaskHelpers.getDuration() was implemented in Story 2.1 and is the correct, tested method for calculating task lifetime. Do NOT reimplement duration calculation logic. [Source: Story 2.1 Dev Notes]

### File Locations & Project Structure

**Service File Location** [Source: architecture/2-high-level-architecture/repository-structure.md#Backend Directory Structure]:
- **Path:** `apps\server\src\services\AnalyticsService.ts`
- **Pattern:** PascalCase for service/class files
- **Naming Convention:** `{ServiceName}Service.ts`

**Test File Location** [Source: architecture/2-high-level-architecture/repository-structure.md#Backend Directory Structure]:
- **Path:** `apps\server\tests\unit\services\AnalyticsService.test.ts`
- **Pattern:** Mirror source structure with `.test.ts` suffix

**Import Paths:**
```typescript
// ✅ Correct - Import shared types using workspace alias
import type { Task, TaskStatus } from '@simple-todo/shared/types';
import { TaskHelpers } from '@simple-todo/shared/utils';

// ✅ Correct - Import from other services using relative paths
import { TaskService } from './TaskService';
import { DataService } from './DataService';
```

### Service Dependencies

**Dependency Injection Pattern** [Source: architecture/2-high-level-architecture/architectural-patterns.md]:
AnalyticsService depends on TaskService for data access. Use constructor injection for testability:

```typescript
export class AnalyticsService {
  constructor(private taskService: TaskService) {}

  async getCompletionRate(): Promise<number> {
    const tasks = await this.taskService.getAllTasks();
    // ... calculation logic
  }
}
```

**Why TaskService instead of DataService?**
- TaskService already provides `getAllTasks()` method
- Maintains consistent service layer abstraction
- TaskService handles any business logic validation
- Easier to mock in unit tests

### Edge Cases & Error Handling

**Critical Edge Cases to Handle** [Source: Epic 2 Story 2.7 AC7]:

1. **Empty Task List:** No tasks exist in the system
   - `getCompletionRate()` → return `0` (not NaN from 0/0)
   - `getAverageTaskLifetime()` → return `null`
   - `getTaskCountByStatus()` → return `{ active: 0, completed: 0 }`
   - `getOldestActiveTask()` → return `null`

2. **No Completed Tasks:** All tasks are active
   - `getCompletionRate()` → return `0` (0/total tasks)
   - `getAverageTaskLifetime()` → return `null` (cannot average 0 items)

3. **No Active Tasks:** All tasks are completed
   - `getOldestActiveTask()` → return `null`
   - `getTaskCountByStatus()` → return `{ active: 0, completed: X }`

4. **Division by Zero:** Prevent NaN results
   - Check for zero denominators before division
   - Return sensible defaults (0, null, empty object)

**Error Propagation:**
If TaskService throws an error (e.g., file system failure), let it propagate. AnalyticsService should NOT catch and hide these errors - they indicate system-level problems that should be logged and handled at the API layer.

### Testing

**Test File Location:** `apps\server\tests\unit\services\AnalyticsService.test.ts`

**Testing Framework:** Jest for backend testing [Source: architecture/3-tech-stack.md, architecture/10-testing-strategy.md]

**Coverage Target:** 70%+ for AnalyticsService [Source: architecture/10-testing-strategy.md#Coverage Requirements]

**Key Test Categories:**
1. **Edge Case Handling:** Empty lists, no completed tasks, no active tasks
2. **Calculation Accuracy:** Verify correct percentages, averages, counts
3. **Data Type Handling:** Verify null returns, object structures
4. **TaskHelpers Integration:** Ensure proper use of getDuration()

**Testing Pattern - Unit Tests with Mocked Dependencies** [Source: architecture/10-testing-strategy.md#Test Examples]:

```typescript
import { AnalyticsService } from '../../../src/services/AnalyticsService';
import { TaskService } from '../../../src/services/TaskService';

jest.mock('../../../src/services/TaskService');

describe('AnalyticsService', () => {
  let analyticsService: AnalyticsService;
  let mockTaskService: jest.Mocked<TaskService>;

  beforeEach(() => {
    mockTaskService = new TaskService() as jest.Mocked<TaskService>;
    analyticsService = new AnalyticsService(mockTaskService);
  });

  describe('getCompletionRate', () => {
    it('should return 0 when no tasks exist', async () => {
      mockTaskService.getAllTasks.mockResolvedValue([]);
      const rate = await analyticsService.getCompletionRate();
      expect(rate).toBe(0);
    });

    it('should calculate correct percentage for mixed dataset', async () => {
      const tasks = [
        createTestTask({ status: 'completed' }),
        createTestTask({ status: 'completed' }),
        createTestTask({ status: 'completed' }),
        createTestTask({ status: 'active' }),
        createTestTask({ status: 'active' }),
      ];
      mockTaskService.getAllTasks.mockResolvedValue(tasks);

      const rate = await analyticsService.getCompletionRate();
      expect(rate).toBeCloseTo(60.0); // 3/5 * 100 = 60%
    });
  });
});
```

**Test Data Factories** [Source: architecture/10-testing-strategy.md#Test Data Factories]:
Use the existing `createTestTask()` helper from `apps/server/tests/helpers/factories.ts`:

```typescript
import { createTestTask } from '../../helpers/factories';

const activeTask = createTestTask({
  status: 'active',
  createdAt: '2026-01-20T10:00:00.000Z'
});

const completedTask = createTestTask({
  status: 'completed',
  createdAt: '2026-01-20T10:00:00.000Z',
  completedAt: '2026-01-21T15:30:00.000Z'
});
```

**Test Execution Commands:**
```bash
# Run only AnalyticsService tests
npm run test:server -- AnalyticsService.test.ts

# Run with coverage report
npm run test:coverage
```

### TypeScript Standards

**Explicit Return Types** [Source: architecture/13-coding-standards-conventions.md#TypeScript Standards]:
```typescript
// ✅ Correct - explicit return type on public methods
export async function getCompletionRate(): Promise<number> {
  // Implementation
}

// ✅ Correct - explicit return type with union
export async function getOldestActiveTask(): Promise<Task | null> {
  // Implementation
}
```

**Type Imports** [Source: architecture/13-coding-standards-conventions.md#TypeScript Standards]:
```typescript
// ✅ Correct - use type imports for type-only imports
import type { Task, TaskStatus } from '@simple-todo/shared/types';
import { TaskService } from './TaskService';
```

**JSDoc Documentation** [Source: architecture/13-coding-standards-conventions.md#Documentation Standards]:
All public methods require JSDoc comments:

```typescript
/**
 * Calculates the task completion rate as a percentage
 *
 * @returns Percentage of completed tasks (0-100)
 * @example
 * const rate = await analyticsService.getCompletionRate();
 * console.log(rate); // 60.0 (if 3 of 5 tasks completed)
 */
export async function getCompletionRate(): Promise<number> {
  // Implementation
}
```

### Performance Considerations

**On-Demand Calculation** [Source: Epic 2 Story 2.7 AC8]:
- Analytics calculated on-demand (not cached) for MVP simplicity
- Acceptable performance for <10k tasks
- Each method fetches all tasks and performs calculations in-memory
- No optimization needed for MVP - YAGNI (You Aren't Gonna Need It)

**Future-Proofing for Phase 2** [Source: Epic 2 Story 2.7 AC10]:
The service architecture should support future API endpoints without refactoring:
- Methods are async (ready for future database migration)
- Clean interface makes it easy to add caching layer later
- Service pattern allows adding middleware (rate limiting, auth) without changes

### Previous Story Insights

**From Story 2.1 (Task Metadata Calculation Infrastructure):**
- TaskHelpers.getDuration() is the canonical way to calculate task lifetime
- Testing infrastructure is set up for shared package
- Computed properties pattern: derive values on-demand, don't store them
- [Source: Story 2.1 Dev Notes, Dev Agent Record]

**Key Lesson:** Follow the established pattern of using TaskHelpers utilities rather than reimplementing calculation logic. This ensures consistency and leverages tested code.

### No API Endpoints Required

**Important:** This story creates the AnalyticsService business logic layer ONLY. API endpoints (e.g., `GET /api/analytics/tasks`) are deferred to Phase 2 per PRD. [Source: architecture/5-api-specification.md, Epic 2 Story 2.7]

The service should be designed so that future API routes can easily call these methods:
```typescript
// Future Phase 2 API route (DO NOT implement now)
router.get('/api/analytics/tasks', async (req, res) => {
  const analytics = {
    completionRate: await analyticsService.getCompletionRate(),
    averageTaskLifetime: await analyticsService.getAverageTaskLifetime(),
    taskCountByStatus: await analyticsService.getTaskCountByStatus(),
    oldestActiveTask: await analyticsService.getOldestActiveTask(),
  };
  res.json(analytics);
});
```

## Change Log

| Date       | Version | Description                          | Author        |
|------------|---------|--------------------------------------|---------------|
| 2026-01-29 | 1.0     | Story created                        | Bob (SM)      |
| 2026-01-29 | 1.1     | Implementation completed and tested  | James (Dev)   |

## Dev Agent Record

### Agent Model Used

Claude Sonnet 4.5 (claude-sonnet-4-5)

### Debug Log References

None - Implementation completed without issues requiring debug logging.

### Completion Notes List

- Created AnalyticsService with all 4 required methods: getCompletionRate(), getAverageTaskLifetime(), getTaskCountByStatus(), getOldestActiveTask()
- All methods implement comprehensive edge case handling (empty lists, no completed tasks, no active tasks)
- Used TaskHelpers.getDuration() for lifetime calculations as specified in Dev Notes
- Followed singleton service pattern with constructor dependency injection
- Comprehensive unit tests created with 16 test cases covering all edge cases and calculation scenarios
- All tests use mocked TaskService dependency following existing patterns
- Code passes TypeScript type checking, ESLint, and Prettier formatting
- Service exported and ready for future Phase 2 API integration (no routes created per story requirements)

### File List

**New Files:**
- `apps/server/src/services/AnalyticsService.ts` - Main service implementation with 4 analytics methods
- `apps/server/tests/unit/services/AnalyticsService.test.ts` - Comprehensive unit tests with 16 test cases

**Modified Files:**
- None (no existing files modified)

## QA Results

### Review Date: 2026-01-29

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

Exemplary implementation demonstrating excellent software engineering practices. The AnalyticsService exhibits clean architecture with proper dependency injection, comprehensive edge case handling, and defensive programming patterns. All four analytics methods (getCompletionRate, getAverageTaskLifetime, getTaskCountByStatus, getOldestActiveTask) are implemented correctly with explicit return types, thorough JSDoc documentation, and sensible default handling for edge cases (null returns, zero division prevention).

Key strengths:
- **Architectural alignment**: Follows established service layer pattern with constructor dependency injection
- **Reuse of tested utilities**: Properly leverages TaskHelpers.getDuration() from Story 2.1 rather than reimplementing calculation logic
- **Type safety**: Full TypeScript strict mode compliance with explicit return types and type imports
- **Documentation**: Comprehensive JSDoc with formulas, edge case descriptions, and usage examples
- **Defensive programming**: Filters null durations in getAverageTaskLifetime (line 85) even though it shouldn't occur for completed tasks

### Refactoring Performed

No refactoring required. The implementation is production-ready as-is.

### Requirements Traceability

**Complete AC Coverage (10/10):**

- **AC1** ✓ AnalyticsService class with 4 methods → AnalyticsService.ts:23-149
- **AC2** ✓ getCompletionRate() formula correct → AnalyticsService.ts:44-54
  - Tests: test.ts:22-28 (empty), 30-41 (no completed), 43-54 (all completed), 56-72 (mixed)
- **AC3** ✓ getAverageTaskLifetime() using TaskHelpers → AnalyticsService.ts:72-94
  - Tests: test.ts:76-82 (empty), 84-95 (no completed), 97-112 (single), 114-139 (multiple), 141-162 (mixed)
- **AC4** ✓ getTaskCountByStatus() returns correct object → AnalyticsService.ts:105-115
  - Tests: test.ts:166-172 (empty), 174-185 (all active), 187-198 (all completed), 200-215 (mixed)
- **AC5** ✓ getOldestActiveTask() finds earliest → AnalyticsService.ts:133-148
  - Tests: test.ts:219-225 (empty), 227-237 (no active), 239-251 (single), 253-277 (multiple), 279-304 (ignores completed)
- **AC6** ✓ Reads from TaskService via DI → AnalyticsService.ts:24-27
- **AC7** ✓ All edge cases handled → Verified in implementation (lines 48, 77, 87, 138) and 16 test cases
- **AC8** ✓ On-demand calculation (no caching) → Each method calls getAllTasks() fresh
- **AC9** ✓ Comprehensive unit tests → 16 test cases covering all scenarios (all active, all completed, mixed, empty)
- **AC10** ✓ Foundation for Phase 2 → Async methods, clean interface, ready for API integration

### Compliance Check

- **Coding Standards**: ✓ PASS
  - Type imports used correctly (line 1: `import type`)
  - Explicit return types on all public methods
  - JSDoc documentation on all methods with @example tags
  - Prettier formatting compliant
- **Project Structure**: ✓ PASS
  - Correct file location: `apps/server/src/services/AnalyticsService.ts`
  - Test mirror structure: `apps/server/tests/unit/services/AnalyticsService.test.ts`
  - Follows PascalCase naming for service class files
- **Testing Strategy**: ✓ PASS
  - Jest framework used for backend testing
  - Proper mocking with `jest.Mocked<TaskService>`
  - Uses test factory (createTestTask) as recommended
  - 16 test cases provide comprehensive coverage
  - Tests organized by method with describe blocks
- **All ACs Met**: ✓ PASS (10/10 acceptance criteria fully satisfied)

### Test Architecture Assessment

**Coverage**: Comprehensive (16 test cases)
**Test Levels**: Appropriate (unit tests with mocked dependencies)
**Edge Cases**: Excellent coverage
  - Empty task lists
  - All active scenarios
  - All completed scenarios
  - Mixed state datasets
  - Single vs multiple items
  - Null return handling

**Test Quality**:
- Proper arrange-act-assert pattern
- Clear test names describing scenarios
- Use of toBeCloseTo() for floating point comparisons (test.ts:71)
- Defensive null handling tested (test.ts:85, 87)

### Non-Functional Requirements

**Security**: ✓ PASS
- Read-only operations, no user input processing
- No authentication/authorization concerns (internal service)
- No data exposure risks (business logic layer)

**Performance**: ✓ PASS
- On-demand calculation appropriate for MVP (<10k tasks)
- In-memory operations are fast
- No N+1 queries or inefficient algorithms
- Future-ready: async methods support database migration

**Reliability**: ✓ PASS
- Comprehensive edge case handling prevents NaN/undefined errors
- Defensive programming (null filtering at test.ts:85)
- Clear error propagation from TaskService layer
- No unhandled promise rejections

**Maintainability**: ✓ PASS
- Excellent code readability
- Comprehensive JSDoc documentation
- Clean separation of concerns
- Testable design (dependency injection)
- Follows established patterns from existing services

### Security Review

No security concerns identified. This is an internal business logic service that performs read-only analytics calculations. It does not:
- Accept user input
- Expose sensitive data
- Perform authentication/authorization
- Make external network calls
- Write to the filesystem

### Performance Considerations

Performance is appropriate for MVP requirements:
- On-demand calculation is acceptable for <10k tasks per AC8
- All operations are O(n) where n = task count
- In-memory operations complete in milliseconds
- No optimization needed at this stage (YAGNI principle)

**Future scalability** (Phase 2 considerations documented but not needed for MVP):
- Can add caching layer without refactoring
- Async methods ready for database migration
- Service pattern allows adding rate limiting/monitoring

### Files Modified During Review

None - no refactoring was necessary. Implementation is production-ready.

### Gate Status

**Gate: PASS** → docs/qa/gates/2.7-analytics-service-behavioral-data-tracking.yml

All acceptance criteria met with comprehensive test coverage and excellent code quality. No blocking issues identified.

### Recommended Status

**✓ Ready for Done**

The story is complete and production-ready. All 10 acceptance criteria are fully satisfied with comprehensive test coverage (16 test cases), excellent code quality, and full standards compliance. No changes required.
