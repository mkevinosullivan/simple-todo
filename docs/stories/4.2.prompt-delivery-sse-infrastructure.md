# Story 4.2: Prompt Delivery - Server-Sent Events (SSE) Infrastructure

<!-- Powered by BMAD™ Core -->

## Status

Done

## Story

**As a** developer,
**I want** Server-Sent Events implemented for real-time prompt delivery from backend to frontend,
**so that** prompts can be pushed to the browser without polling.

## Acceptance Criteria

1. SSE endpoint created: `GET /api/prompts/stream` establishes persistent connection for prompt delivery
2. Endpoint sends `keep-alive` messages every 30 seconds to maintain connection
3. When PromptingService generates prompt, server sends event through SSE stream: `event: prompt\ndata: {taskId, taskText, promptedAt}\n\n`
4. Frontend SSE client (EventSource) connects to stream on app load
5. Connection automatically reconnects if dropped (EventSource handles this by default)
6. Multiple browser tabs/windows supported - each receives prompts independently
7. SSE endpoint only sends prompts if prompting enabled in config
8. Graceful degradation: If SSE not supported (old browsers), fall back to periodic polling (optional for MVP)
9. Integration tests verify: SSE connection established, events received by client, reconnection works
10. Performance: SSE connection uses minimal resources, doesn't impact app responsiveness

## Tasks / Subtasks

**Note:** Tasks 1-3 can be developed in parallel. Task 9 (verify shared types) can be executed first if preferred.

- [x] **Task 1: Create SSE Endpoint Route** (AC: 1, 2, 3, 7)
  - [x] Create `apps/server/src/routes/prompts.ts`
  - [x] Define `GET /api/prompts/stream` route handler
  - [x] Set SSE headers: `Content-Type: text/event-stream`, `Cache-Control: no-cache`, `Connection: keep-alive`
  - [x] Check config.promptingEnabled before establishing connection (AC 7)
  - [x] If prompting disabled, immediately close connection with appropriate message
  - [x] Implement 30-second keep-alive heartbeat using `setInterval` (AC 2)
  - [x] Define keep-alive interval constant: `const KEEP_ALIVE_INTERVAL_MS = 30000` for maintainability
  - [x] Send keep-alive messages: `: keep-alive\n\n` (comment syntax)
  - [x] Store active SSE connections in memory (Map or Set) for broadcasting
  - [x] Clean up connection on client disconnect (remove from active connections)
  - [x] Add error handling for write failures
  - [x] Use Winston logger to log connection events (connected, disconnected, errors)
  - [Source: docs/architecture/5-api-specification.md, docs/architecture/2-high-level-architecture.md]

- [x] **Task 2: Integrate PromptingService with SSE Endpoint** (AC: 3)
  - [x] Modify PromptingService to emit prompt events instead of just logging
  - [x] Add EventEmitter to PromptingService or use a shared event bus
  - [x] Update `onScheduledPrompt()` method in PromptingService to emit 'prompt' event with ProactivePrompt data
  - [x] In prompts route, subscribe to PromptingService prompt events
  - [x] When prompt event received, broadcast to all active SSE connections
  - [x] Format SSE message: `event: prompt\ndata: ${JSON.stringify(promptData)}\n\n`
  - [x] Ensure prompt only sent to connections where prompting is enabled (check config per connection if needed)
  - [x] Test that prompts generated by scheduler are delivered via SSE
  - [Source: docs/stories/4.1.prompting-service-core-scheduling-logic.md lines 82-83]

- [x] **Task 3: Create Frontend SSE Hook (useSSE)** (AC: 4, 5, 6)
  - [x] Create `apps/web/src/hooks/useSSE.ts`
  - [x] Implement `useSSE` custom hook using EventSource API
  - [x] Connect to `/api/prompts/stream` on component mount (AC 4)
  - [x] Listen for 'prompt' events from SSE stream
  - [x] Parse event data as ProactivePrompt type
  - [x] Maintain connection state: 'connecting', 'connected', 'disconnected', 'error'
  - [x] Handle automatic reconnection (EventSource default behavior, AC 5)
  - [x] Add manual reconnect logic with exponential backoff if needed
  - [x] Clean up EventSource connection on unmount (`eventSource.close()`)
  - [x] Return connection state and received prompts from hook
  - [x] Support multiple tabs: Each tab gets its own EventSource connection (AC 6)
  - [x] Add error handling for connection failures:
    - [x] Network timeout scenarios
    - [x] Server restart (rely on automatic reconnection)
    - [x] 503 Service Unavailable responses
    - [x] CORS issues (if applicable)
  - [Source: docs/architecture/2-high-level-architecture.md lines 104-110, docs/architecture/6-components.md lines 344-356]

- [x] **Task 4: Integrate useSSE Hook with App** (AC: 4, 6)
  - [x] Import and call `useSSE()` in root App component or TaskListView
  - [x] Pass received prompts to a prompt display component (Story 4.3 will create PromptToast)
  - [x] For MVP, log received prompts to console to verify delivery
  - [x] Ensure SSE connection starts automatically when app loads
  - [x] Verify multiple browser tabs each establish independent SSE connections
  - [x] Test that closing tab properly closes SSE connection (no memory leaks)

- [x] **Task 5: Add Graceful Degradation for Old Browsers** (AC: 8 - Optional for MVP)
  - [x] Check if EventSource is supported: `if (typeof EventSource !== 'undefined')`
  - [x] If not supported, log warning to console
  - [ ] Optionally implement fallback: polling `/api/prompts/check` every 60 seconds (Deferred - not needed for MVP)
  - [x] For MVP, graceful degradation can just show a message: "SSE not supported, upgrade browser"
  - [x] Mark as optional/future enhancement if time-constrained

- [x] **Task 6: Write Backend Integration Tests** (AC: 9)
  - [x] Create `apps/server/tests/integration/api/prompts.test.ts`
  - [x] Test: SSE connection established successfully
    - [x] Use supertest to connect to `/api/prompts/stream`
    - [x] Verify response headers (Content-Type: text/event-stream)
    - [x] Verify connection remains open
  - [x] Test: Keep-alive messages received every 30 seconds
    - [x] Assert keep-alive comments appear in stream
  - [x] Test: Prompt event delivered through SSE when PromptingService emits
    - [x] Trigger prompt generation manually
    - [x] Assert event received with correct format and data
  - [x] Test: Connection closed when prompting disabled
    - [x] Set config.promptingEnabled = false
    - [x] Attempt to connect
    - [x] Verify connection closes or rejects
  - [x] Test: Multiple connections supported
    - [x] Open 2+ simultaneous SSE connections
    - [x] Trigger prompt
    - [x] Verify all connections receive the event
  - [Source: docs/architecture/10-testing-strategy.md]

- [x] **Task 7: Write Frontend Integration Tests** (AC: 9)
  - [x] Create `apps/web/tests/unit/hooks/useSSE.test.ts`
  - [x] Mock EventSource API for testing
  - [x] Test: useSSE hook connects to /api/prompts/stream on mount
  - [x] Test: Hook receives and parses prompt events correctly
  - [x] Test: Hook updates connection state appropriately
  - [x] Test: EventSource connection closed on unmount
  - [x] Test: Reconnection logic triggered on connection drop
  - [x] Use Mock Service Worker (MSW) or EventSource mocks
  - [Source: docs/architecture/10-testing-strategy.md lines 104-126]

- [ ] **Task 8: Manual End-to-End Testing** (AC: 10) - **Requires QA validation**
  - [ ] Start backend server (`npm run dev -w @simple-todo/server`)
  - [ ] Start frontend dev server (`npm run dev -w @simple-todo/web`)
  - [ ] Enable prompting in config.json (set `promptingEnabled: true`)
  - [ ] Open browser DevTools Network tab, filter for EventStream
  - [ ] Verify SSE connection established to `/api/prompts/stream`
  - [ ] Verify keep-alive messages appear every 30 seconds
  - [ ] Wait for scheduled prompt (or manually trigger via PromptingService)
  - [ ] Verify prompt event appears in SSE stream with correct data
  - [ ] Check console for logged prompt (Task 4 MVP logging)
  - [ ] Open second browser tab, verify second SSE connection established
  - [ ] Trigger prompt, verify both tabs receive the same prompt event
  - [ ] Close one tab, verify SSE connection closed (check server logs)
  - [ ] Disable prompting (`promptingEnabled: false`), verify no new connections allowed
  - [ ] Monitor browser memory and CPU usage - verify minimal impact (AC 10)

- [x] **Task 9: Update Shared Types** (AC: 3)
  - [x] Verify ProactivePrompt interface exists in `packages/shared/src/types/PromptEvent.ts` (already created in Story 4.1)
  - [x] If not present, add:
    ```typescript
    export interface ProactivePrompt {
      taskId: string;
      taskText: string;
      promptedAt: string; // ISO 8601
    }
    ```
  - [x] Export from `packages/shared/src/types/index.ts`
  - [x] Ensure both backend and frontend import from shared package

- [x] **Task 10: Documentation and Code Quality** (AC: All)
  - [x] Add JSDoc comments to SSE route handler explaining SSE protocol
  - [x] Add JSDoc comments to useSSE hook with usage example
  - [x] Document SSE connection lifecycle in inline comments
  - [x] Run `npm run type-check` - ensure no TypeScript errors
  - [x] Run `npm run lint` - ensure no ESLint violations
  - [x] Run `npm run format` - ensure code formatted by Prettier
  - [x] Run `npm test` - ensure all tests passing
  - [x] Update README.md with note: "Real-time prompts delivered via Server-Sent Events (Story 4.2)"

## Dev Notes

### Epic 4 Context

This is the second story in Epic 4 (Proactive Prompting System). Story 4.1 built the PromptingService scheduler that generates prompts. Story 4.2 now adds the **real-time delivery mechanism** to push those prompts from the backend to the browser without polling.

**Story 4.2 Focus:** SSE infrastructure only - implements the communication channel. Story 4.3 will add the PromptToast UI component to display the prompts.

**Epic Story Breakdown:**
- **Story 4.1 (Complete):** Core scheduling logic and task selection (backend only)
- **Story 4.2 (This Story):** SSE infrastructure for real-time prompt delivery to browser
- **Story 4.3:** Toast notification UI component
- **Story 4.4:** User response handling (complete/dismiss/snooze)

### Previous Story Insights (Story 4.1)

[Source: docs/stories/4.1.prompting-service-core-scheduling-logic.md]

**Key Learnings from Story 4.1:**
- PromptingService successfully implemented with `generatePrompt()` method that creates ProactivePrompt objects
- Service currently logs prompts but doesn't deliver them to frontend
- Integration point: `apps/server/src/index.ts` or `apps/server/src/app.ts` initializes PromptingService
- ProactivePrompt interface already defined in `packages/shared/src/types/PromptEvent.ts`:
  ```typescript
  export interface ProactivePrompt {
    taskId: string;
    taskText: string;
    promptedAt: string; // ISO 8601
  }
  ```
- PromptingService has `onScheduledPrompt()` method that needs to be modified to emit events instead of just logging (lines 82-83 of Story 4.1)

**Story 4.2 Integration Point:**
- Modify PromptingService to emit prompt events via EventEmitter or similar mechanism
- Create SSE endpoint that listens for these events and broadcasts to connected clients

### Tech Stack Context

[Source: docs/architecture/3-tech-stack.md]

**Key Technologies for This Story:**

| Technology                | Version    | Purpose                          | Notes                                                      |
| ------------------------- | ---------- | -------------------------------- | ---------------------------------------------------------- |
| **Server-Sent Events**    | Native     | Server→client prompting push     | Built into browsers and Node.js, simpler than WebSockets   |
| **Express.js**            | 4.18+      | HTTP server and SSE routing      | Native SSE support via response streaming                  |
| **EventSource API**       | Native     | Browser SSE client               | Built into modern browsers, automatic reconnection         |
| **React**                 | 18.2+      | Frontend hooks and components    | useSSE custom hook pattern                                 |
| **TypeScript**            | 5.3+       | Type-safe SSE implementation     | Strict mode enabled, explicit return types required        |
| **Winston**               | 3.11+      | Structured logging               | Log SSE connection events (connect, disconnect, errors)    |
| **Jest**                  | 29.7+      | Backend integration tests        | Test SSE endpoint with supertest                           |
| **Vitest**                | 1.0+       | Frontend hook tests              | Mock EventSource API for useSSE tests                      |

**IMPORTANT - SSE Technology Choice:**
- SSE is native to browsers (EventSource API) and Node.js (response streaming)
- Chosen over WebSockets because PRD only requires **one-way push** (server→client)
- SSE provides automatic reconnection out-of-the-box
- Simpler protocol than WebSockets: just HTTP response that stays open
- No additional libraries needed beyond Express.js

### SSE Implementation Pattern

[Source: docs/architecture/2-high-level-architecture.md, docs/architecture/6-components.md]

**Backend SSE Endpoint Pattern:**

```typescript
// apps/server/src/routes/prompts.ts
import type { Request, Response } from 'express';
import { logger } from '../utils/logger.js';

export function streamPrompts(req: Request, res: Response): void {
  // Set SSE headers
  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');
  res.flushHeaders();

  // Send keep-alive every 30 seconds
  const keepAliveInterval = setInterval(() => {
    res.write(': keep-alive\n\n');
  }, 30000);

  // Listen for prompt events from PromptingService
  const onPrompt = (prompt: ProactivePrompt) => {
    res.write(`event: prompt\n`);
    res.write(`data: ${JSON.stringify(prompt)}\n\n`);
  };

  promptingService.on('prompt', onPrompt);

  // Cleanup on disconnect
  req.on('close', () => {
    clearInterval(keepAliveInterval);
    promptingService.off('prompt', onPrompt);
    logger.info('SSE connection closed');
  });

  logger.info('SSE connection established');
}
```

**Frontend EventSource Hook Pattern:**

[Source: docs/architecture/6-components.md lines 344-356]

```typescript
// apps/web/src/hooks/useSSE.ts
import { useEffect, useState } from 'react';
import type { ProactivePrompt } from '@simple-todo/shared/types';

export function useSSE() {
  const [prompts, setPrompts] = useState<ProactivePrompt[]>([]);
  const [connectionState, setConnectionState] = useState<'connecting' | 'connected' | 'disconnected' | 'error'>('connecting');

  useEffect(() => {
    // Note: Use environment-based API URL from existing api.ts client pattern
    const eventSource = new EventSource('http://localhost:3001/api/prompts/stream');

    eventSource.addEventListener('open', () => {
      setConnectionState('connected');
      console.log('SSE connection opened');
    });

    // Listen for custom 'prompt' events (specified by server's "event: prompt" line)
    eventSource.addEventListener('prompt', (event) => {
      const prompt: ProactivePrompt = JSON.parse(event.data);
      setPrompts(prev => [...prev, prompt]);
      console.log('Received prompt:', prompt);
    });

    eventSource.addEventListener('error', (error) => {
      setConnectionState('error');
      console.error('SSE error:', error);
    });

    return () => {
      eventSource.close();
    };
  }, []);

  return { prompts, connectionState };
}
```

### Data Models

[Source: docs/architecture/4-data-models.md lines 352-356]

**ProactivePrompt Interface (Already Created in Story 4.1):**

```typescript
export interface ProactivePrompt {
  taskId: string;
  taskText: string;
  promptedAt: string; // ISO 8601
}
```

**Example SSE Event Data:**

```
event: prompt
data: {"taskId":"123e4567-e89b-12d3-a456-426614174000","taskText":"Buy groceries","promptedAt":"2026-02-05T14:30:00.000Z"}

```

### Service Layer Architecture

[Source: docs/architecture/6-components.md lines 139-189, docs/stories/4.1.prompting-service-core-scheduling-logic.md]

**PromptingService Integration:**

PromptingService from Story 4.1 currently logs prompts. We need to modify it to **emit events** instead:

**Current Implementation (Story 4.1):**
```typescript
async onScheduledPrompt(): Promise<void> {
  // ... check for active tasks ...
  const prompt = await this.generatePrompt();
  if (prompt) {
    // Currently just logs
    logger.info('Scheduled prompt triggered', { prompt });
  }
}
```

**Required Modification (Story 4.2):**
```typescript
import { EventEmitter } from 'events';

class PromptingService extends EventEmitter {
  // ... existing code ...

  async onScheduledPrompt(): Promise<void> {
    // ... check for active tasks ...
    const prompt = await this.generatePrompt();
    if (prompt) {
      logger.info('Scheduled prompt triggered', { prompt });
      // NEW: Emit event for SSE to broadcast
      this.emit('prompt', prompt);
    }
  }
}
```

**File Location:**
- Modify existing: `apps/server/src/services/PromptingService.ts`
- New route file: `apps/server/src/routes/prompts.ts`
- New hook file: `apps/web/src/hooks/useSSE.ts`

### API Specification

[Source: docs/architecture/5-api-specification.md lines 21]

**SSE Endpoint Specification:**

**Endpoint:** `GET /api/prompts/stream`

**Purpose:** Establish persistent SSE connection for real-time prompt delivery

**Request:**
```http
GET /api/prompts/stream HTTP/1.1
Host: localhost:3001
Accept: text/event-stream
```

**Response (Streaming):**
```
HTTP/1.1 200 OK
Content-Type: text/event-stream
Cache-Control: no-cache
Connection: keep-alive

: keep-alive

: keep-alive

event: prompt
data: {"taskId":"abc123","taskText":"Buy groceries","promptedAt":"2026-02-05T14:30:00.000Z"}

: keep-alive
```

**Event Format:**
- Keep-alive: `: keep-alive\n\n` (comment, ignored by EventSource)
- Prompt event: `event: prompt\ndata: {JSON}\n\n`

**Response Codes:**
- `200 OK`: Connection established successfully
- `500 Internal Server Error`: Server error (log details with Winston)

**Connection Lifecycle:**
1. Client sends GET request
2. Server responds with SSE headers, keeps connection open
3. Server sends keep-alive every 30 seconds
4. When prompt generated, server sends event
5. Client receives event via EventSource API
6. Connection remains open until client closes or server crashes
7. EventSource automatically reconnects on disconnect

### Frontend Architecture

[Source: docs/architecture/2-high-level-architecture.md lines 104-110]

**Frontend Integration Pattern:**

The `useSSE` hook will be called in the root App component or TaskListView. For Story 4.2 MVP, we'll just log received prompts to console. Story 4.3 will add the PromptToast component to display them.

**File Location:**
- Hook: `apps/web/src/hooks/useSSE.ts`
- Integration: `apps/web/src/App.tsx` or `apps/web/src/views/TaskListView.tsx`

**Import Pattern:**
```typescript
// In App.tsx or TaskListView.tsx
import { useSSE } from '../hooks/useSSE';
import type { ProactivePrompt } from '@simple-todo/shared/types';

function App() {
  const { prompts, connectionState } = useSSE();

  useEffect(() => {
    if (prompts.length > 0) {
      const latestPrompt = prompts[prompts.length - 1];
      console.log('Received prompt:', latestPrompt);
      // Story 4.3 will replace console.log with PromptToast display
    }
  }, [prompts]);

  // ... rest of component
}
```

### Testing

[Source: docs/architecture/10-testing-strategy.md]

**Test Standards:**
- **Backend Framework:** Jest 29.7+
- **Frontend Framework:** Vitest 1.0+ with React Testing Library
- **Coverage Target:** 75%+ for PromptingService modifications and SSE route

**Backend Integration Test Pattern:**

```typescript
// apps/server/tests/integration/api/prompts.test.ts
import request from 'supertest';
import { app } from '../../../src/app';

describe('GET /api/prompts/stream', () => {
  it('should establish SSE connection with correct headers', async () => {
    const response = await request(app)
      .get('/api/prompts/stream')
      .expect(200)
      .expect('Content-Type', /text\/event-stream/);

    expect(response.headers['cache-control']).toBe('no-cache');
    expect(response.headers['connection']).toBe('keep-alive');
  });

  it('should send keep-alive messages', (done) => {
    request(app)
      .get('/api/prompts/stream')
      .buffer()
      .end((err, res) => {
        if (err) return done(err);
        expect(res.text).toContain(': keep-alive');
        done();
      });
  });

  it('should broadcast prompt event when PromptingService emits', (done) => {
    // Setup: manually trigger prompt generation
    // Assert: event received in SSE stream
    // This test requires accessing PromptingService instance
    done();
  });
});
```

**Frontend Hook Test Pattern:**

```typescript
// apps/web/tests/unit/hooks/useSSE.test.ts
import { renderHook, waitFor } from '@testing-library/react';
import { useSSE } from '../../../src/hooks/useSSE';

// Mock EventSource API
global.EventSource = class EventSource {
  addEventListener = jest.fn();
  close = jest.fn();
} as any;

describe('useSSE', () => {
  it('should connect to SSE endpoint on mount', () => {
    const { result } = renderHook(() => useSSE());
    expect(result.current.connectionState).toBe('connecting');
  });

  it('should update state when prompt received', async () => {
    const { result } = renderHook(() => useSSE());
    // Simulate receiving a prompt event
    // Assert prompts array updated
  });

  it('should close connection on unmount', () => {
    const { unmount } = renderHook(() => useSSE());
    unmount();
    // Assert EventSource.close() called
  });
});
```

**Test Execution Commands:**
```bash
# Run backend SSE tests only
npm run test -w @simple-todo/server -- prompts.test.ts

# Run frontend useSSE tests only
npm run test -w @simple-todo/web -- useSSE.test.ts

# Run with coverage
npm run test:coverage

# Watch mode for development
npm run test:watch
```

### Coding Standards

[Source: docs/architecture/13-coding-standards-conventions.md]

**File Naming:**
- Backend route: `prompts.ts` (lowercase, PascalCase for classes inside)
- Frontend hook: `useSSE.ts` (camelCase with 'use' prefix)
- Tests: `prompts.test.ts`, `useSSE.test.ts` (match source file + `.test`)

**Import Order (ESLint enforced):**
```typescript
// Backend prompts.ts
import { Router } from 'express'; // External dependencies
import type { ProactivePrompt } from '@simple-todo/shared/types'; // Shared packages
import { promptingService } from '../app.js'; // Parent directories
import { logger } from '../utils/logger.js'; // Utilities

// Frontend useSSE.ts
import { useEffect, useState } from 'react'; // React first
import type { ProactivePrompt } from '@simple-todo/shared/types'; // Shared packages
```

**TypeScript Standards:**
- Explicit return types on all public functions
- Use `import type` for type-only imports
- No `any` type - use `unknown` with type guards
- Strict null checks (use `ProactivePrompt | null`, not `ProactivePrompt?`)

**Constants and Magic Numbers:**
- Define named constants for intervals and timeouts (e.g., `KEEP_ALIVE_INTERVAL_MS = 30000`)
- Use constants instead of inline numbers for better maintainability

**JSDoc Requirements:**
```typescript
/**
 * Establishes Server-Sent Events connection for real-time prompt delivery
 *
 * Streams proactive prompts from PromptingService to connected clients.
 * Sends keep-alive messages every 30 seconds to maintain connection.
 *
 * @returns Streaming SSE response (never completes until client disconnect)
 *
 * @example
 * // Client connects via EventSource
 * const eventSource = new EventSource('/api/prompts/stream');
 * eventSource.addEventListener('prompt', (event) => {
 *   const prompt = JSON.parse(event.data);
 *   console.log(prompt);
 * });
 */
export function streamPrompts(req: Request, res: Response): void {
  // Implementation
}
```

**Pre-Commit Checklist:**
- [ ] `npm run type-check` passes
- [ ] `npm run lint` passes
- [ ] `npm run format:check` passes
- [ ] `npm test` passes
- [ ] All public functions have JSDoc comments
- [ ] No `console.log` statements (use Winston logger for backend, allowed for frontend MVP logging)

### Integration Points

**Backend Integration (`apps/server/src/app.ts` or `apps/server/src/index.ts`):**

```typescript
import promptsRouter from './routes/prompts.js';

// Existing routes
app.use('/api/tasks', tasksRouter);
app.use('/api/config', configRouter);
app.use('/api/celebrations', celebrationsRouter);

// NEW: SSE prompts route (Story 4.2)
app.use('/api/prompts', promptsRouter);
```

**Frontend Integration (`apps/web/src/App.tsx`):**

```typescript
import { useSSE } from './hooks/useSSE';

function App() {
  const { prompts, connectionState } = useSSE();

  // MVP: Just log prompts for Story 4.2
  useEffect(() => {
    if (prompts.length > 0) {
      console.log('Received prompt via SSE:', prompts[prompts.length - 1]);
    }
  }, [prompts]);

  return (
    // ... existing UI
  );
}
```

### Known Limitations (MVP Scope)

- **No Queue Management:** Multiple prompts in rapid succession will all be delivered immediately (Story 4.3 will add PromptQueue to show one at a time)
- **No Browser Notification Fallback:** Old browsers without EventSource support will not receive prompts (graceful degradation is optional AC 8, can defer if time-constrained)
- **No Prompt Persistence:** If browser tab closed during prompt, prompt is lost (Story 4.4 will add prompt event tracking)
- **No Authentication:** SSE connections are unauthenticated (acceptable for localhost single-user MVP)
- **No Connection Pooling:** Each tab opens separate SSE connection (acceptable for MVP, 5-10 pilot users)

### Performance Considerations

[Source: docs/architecture/11-performance-considerations.md, AC 10]

**SSE Performance Requirements:**
- Keep-alive messages: 30 bytes every 30 seconds = 1 byte/second per connection
- Prompt events: ~200 bytes per prompt, 1 prompt every 2-3 hours
- Memory: ~10KB per active SSE connection (negligible for 5-10 users)
- CPU: Minimal (event-driven, no polling)

**Performance Validation:**
- Monitor browser DevTools Performance tab during SSE connection
- Check Network tab: verify no request queuing or blocking
- Verify app remains responsive during SSE connection
- Check server memory usage: `ps aux | grep node` (should be <100MB for MVP)

**AC 10 Validation:**
- SSE connection must NOT cause frame drops in browser
- Task operations (add/complete/delete) must remain <100ms (NFR2)
- No noticeable impact on app startup time

### Future Story Dependencies

**Story 4.3 (Toast Notification UI):**
- Will consume `useSSE` hook to display prompts
- Will replace console.log with PromptToast component
- Will add PromptQueue to show one prompt at a time

**Story 4.4 (Response Handling):**
- Will add POST /api/prompts/snooze endpoint
- Will track prompt responses (complete/dismiss/snooze/timeout)
- Will persist prompt events to prompts.json

**Story 4.5 (Configuration):**
- Will add ability to disable prompting (stop SSE connections)
- Will allow changing prompt frequency (restart PromptingService scheduler)

## Testing

[Source: docs/architecture/10-testing-strategy.md]

**Test File Locations:**
- Backend integration tests: `apps/server/tests/integration/api/prompts.test.ts`
- Frontend unit tests: `apps/web/tests/unit/hooks/useSSE.test.ts`
- Test helpers: `apps/server/tests/helpers/factories.ts` (use createTestTask for prompts)

**Testing Standards:**
- **Backend Framework:** Jest 29.7+ with supertest for SSE endpoint testing
- **Frontend Framework:** Vitest 1.0+ with React Testing Library for useSSE hook
- **Coverage Target:** 75%+ for prompts route and useSSE hook

**Specific Testing Requirements for This Story:**

1. **Backend SSE Endpoint Tests:**
   - Test SSE connection established with correct headers
   - Test keep-alive messages sent every 30 seconds
   - Test prompt event broadcast to all connected clients
   - Test connection cleanup on client disconnect
   - Test prompting disabled check (AC 7)
   - Test multiple simultaneous connections (AC 6)

2. **Frontend useSSE Hook Tests:**
   - Test EventSource connection created on mount
   - Test prompt events received and parsed
   - Test connection state updates
   - Test EventSource closed on unmount
   - Test automatic reconnection (verify EventSource default behavior)

3. **Integration Test Pattern:**
   - Use supertest to simulate SSE client
   - Use EventSource mocks for frontend hook tests
   - Test end-to-end: PromptingService emit → SSE broadcast → Frontend receive

**Test Data Factories:**
```typescript
// Use existing createTestTask from helpers/factories.ts
import { createTestTask } from '../../helpers/factories';

const testPrompt: ProactivePrompt = {
  taskId: createTestTask().id,
  taskText: 'Test prompt task',
  promptedAt: new Date().toISOString(),
};
```

## Change Log

| Date       | Version | Description                                      | Author              |
| ---------- | ------- | ------------------------------------------------ | ------------------- |
| 2026-02-05 | 1.0     | Story created with full architecture context     | Bob (Scrum Master)  |
| 2026-02-05 | 1.1     | Validation improvements: Fixed EventSource event listener to use 'prompt' instead of 'message', added API URL comment, added error handling scenarios, added keep-alive constant recommendation, added task parallelization note | Sarah (PO)          |
| 2026-02-05 | 2.0     | Story implementation complete: SSE infrastructure implemented with backend route, PromptingService EventEmitter integration, frontend useSSE hook, comprehensive tests, and documentation. Status: Ready for Review | James (Dev Agent)   |
| 2026-02-05 | 2.1     | QA refactoring applied: Fixed DataService instantiation in prompts.ts to use shared singleton instance. All validation checks passed (type-check, lint, tests). File List updated. Status: Ready for Done | James (Dev Agent)   |

## Dev Agent Record

### Agent Model Used

claude-sonnet-4-5

### Debug Log References

- Fixed circular dependency: Created `apps/server/src/services/index.ts` to export shared service instances, preventing circular import between `index.ts` and `prompts.ts` route
- Used Set data structure for active connections tracking instead of Map for simpler connection management

### Completion Notes List

- SSE endpoint successfully created with proper headers, keep-alive heartbeat, and config checking
- PromptingService now extends EventEmitter and emits 'prompt' events to broadcast to all active SSE connections
- Frontend useSSE hook implements EventSource with full connection state management and error handling
- Comprehensive test coverage: Backend integration tests verify SSE streaming, multiple connections, and prompt broadcasting; Frontend tests mock EventSource API and verify all hook behaviors
- Task 5 (browser fallback) implemented basic EventSource detection with error message; full polling fallback deferred as optional enhancement
- Task 8 (manual E2E testing) deferred to QA validation
- All code quality checks passed: type-check, lint, format:check
- README.md updated with SSE feature documentation
- QA review completed: DataService refactoring verified and validated (shared singleton pattern in prompts.ts). All tests passing post-refactoring. Quality score: 90/100. Gate status: CONCERNS resolved.

### File List

**Created:**
- `apps/server/src/routes/prompts.ts` - SSE endpoint route with streaming logic (refactored during QA review to use shared dataService instance)
- `apps/server/src/services/index.ts` - Shared service instances (resolves circular dependency)
- `apps/web/src/hooks/useSSE.ts` - Frontend SSE hook with EventSource API
- `apps/server/tests/integration/api/prompts.test.ts` - Backend SSE integration tests
- `apps/web/tests/unit/hooks/useSSE.test.ts` - Frontend useSSE hook tests

**Modified:**
- `apps/server/src/services/PromptingService.ts` - Extended EventEmitter, added super() call, emit 'prompt' events
- `apps/server/src/index.ts` - Import shared promptingService instead of creating new instance
- `apps/server/src/app.ts` - Added prompts router registration
- `apps/web/src/App.tsx` - Integrated useSSE hook with console logging for MVP
- `README.md` - Added SSE feature to Features section

## QA Results

### Review Date: 2026-02-05

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall Assessment**: Excellent implementation of SSE infrastructure with comprehensive test coverage and solid architectural patterns. The code demonstrates strong understanding of event-driven architecture, proper resource management, and TypeScript best practices.

**Strengths**:
- Well-structured SSE implementation following Express streaming patterns
- Comprehensive test coverage: 14 tests (5 backend integration, 9 frontend unit tests)
- Excellent documentation with detailed JSDoc comments
- Proper EventEmitter pattern for PromptingService integration
- Clean separation of concerns across routes, services, and hooks
- Type-safe implementation with explicit return types
- Proper cleanup mechanisms preventing memory leaks
- Named constants for magic numbers (KEEP_ALIVE_INTERVAL_MS)

**Areas of Excellence**:
- EventSource auto-reconnection handling with state tracking
- Multiple simultaneous connection support tested and verified
- Graceful degradation for unsupported browsers
- Structured Winston logging throughout
- Atomic service instances preventing circular dependencies

### Refactoring Performed

**File**: `apps/server/src/routes/prompts.ts`
- **Change**: Replaced per-connection DataService instantiation with shared dataService instance from services/index.ts
- **Why**: Each SSE connection was creating a new DataService instance, causing unnecessary overhead and potential state inconsistencies with multiple connections
- **How**:
  - Changed import from `import { DataService }` to `import { dataService }`
  - Removed `const dataService = new DataService(process.env.DATA_DIR)` line 40
  - Now uses the shared singleton instance that's consistent across the application
- **Impact**: Improved performance and resource usage, especially with multiple SSE connections

### Compliance Check

- **Coding Standards**: ✓ PASS
  - Import ordering correct (React first, external, shared, internal)
  - Type imports use `import type` syntax
  - Explicit return types on all public functions
  - Named constants replace magic numbers
  - JSDoc comments on all public APIs

- **Project Structure**: ✓ PASS
  - Routes in `apps/server/src/routes/`
  - Hooks in `apps/web/src/hooks/`
  - Tests mirror source structure
  - Shared types in `packages/shared/src/types/`

- **Testing Strategy**: ✓ PASS
  - Integration tests for backend SSE endpoint
  - Unit tests for frontend hook with EventSource mocking
  - 75%+ coverage target met
  - All critical paths tested
  - Edge cases covered (errors, reconnection, multiple connections)

- **All ACs Met**: ✓ PASS (9/10 fully validated)
  - ACs 1-9: Fully implemented and tested
  - AC 10 (Performance): Implemented but lacks quantitative benchmarks

### Requirements Traceability Matrix

| AC | Requirement | Test Coverage | Status |
|----|-------------|---------------|--------|
| 1 | SSE endpoint created | `prompts.test.ts:38-47` | ✓ PASS |
| 2 | Keep-alive every 30s | `prompts.test.ts:49-84` | ✓ PASS |
| 3 | Prompt event format | `prompts.test.ts:99-142` | ✓ PASS |
| 4 | Frontend connects on load | `useSSE.test.ts:108-112`, `App.tsx:75` | ✓ PASS |
| 5 | Auto-reconnection | `useSSE.test.ts:258-278` | ✓ PASS |
| 6 | Multiple tabs support | `prompts.test.ts:144-198` | ✓ PASS |
| 7 | Config check (prompting enabled) | `prompts.test.ts:86-97`, `prompts.ts:39-48` | ✓ PASS |
| 8 | Graceful degradation | `useSSE.test.ts:220-233`, `useSSE.ts:47-53` | ✓ PASS |
| 9 | Integration tests | 14 comprehensive tests | ✓ PASS |
| 10 | Performance validation | Implementation solid, benchmarks missing | ⚠ PARTIAL |

**Coverage Gap**: AC 10 lacks quantitative performance benchmarks. Implementation uses efficient event-driven architecture with minimal overhead (1 byte/sec keep-alive), but no automated performance tests validate the "minimal resources" claim.

### Improvements Checklist

- [x] Refactored DataService instantiation to use shared singleton (apps/server/src/routes/prompts.ts:5-6, 40)
- [x] Verified all tests pass after refactoring
- [x] Ran type-check and lint - all passing
- [ ] Add performance benchmarks to quantitatively validate AC 10 (recommended for production)
- [ ] Add E2E manual testing (Task 8 - requires QA validation)
- [ ] Consider connection timeout limits for production deployment (low priority)
- [ ] Consider connection rate limiting before scaling beyond MVP (low priority)

### Security Review

**Status**: ✓ PASS

**Findings**:
- No authentication required - acceptable for localhost single-user MVP
- No sensitive data exposed in SSE stream (taskId, taskText, timestamp only)
- Prompting can be disabled via config (defense in depth)
- JSON serialization prevents injection attacks
- No SQL injection or XSS risks identified
- CORS properly configured for localhost:3000 origin

**Recommendations**:
- Current security posture appropriate for MVP
- Before multi-user deployment, consider adding authentication/authorization
- No blocking security concerns

### Performance Considerations

**Status**: ⚠ PASS with CONCERNS

**Findings**:
- Keep-alive overhead: 30 bytes/30 seconds = 1 byte/second per connection (excellent)
- Event-driven architecture eliminates polling overhead
- Proper cleanup prevents memory leaks (verified in tests)
- DataService instantiation issue fixed during review (medium impact)
- Connection pooling not implemented (acceptable for MVP)

**Concerns**:
- No quantitative performance benchmarks or load tests
- No validation of "minimal resources" claim from AC 10
- No connection timeout or max duration limits
- Each browser tab creates independent connection (by design, but no limit)

**Recommendations**:
- Add performance benchmarks before production scale-up
- Monitor connection count and resource usage in production
- Consider connection limits if scaling beyond 5-10 users

### Files Modified During Review

**Refactored**:
- `apps/server/src/routes/prompts.ts` - Fixed DataService instantiation pattern

**Note**: Please verify this file is included in the story's File List.

### Gate Status

**Gate**: CONCERNS → `docs/qa/gates/4.2-prompt-delivery-sse-infrastructure.yml`

**Status Reason**: Solid SSE implementation with comprehensive tests. Identified and fixed DataService instantiation issue during review. Minor performance testing gap remains acceptable for MVP but should be addressed before production scale-up.

**Quality Score**: 90/100

**Risk Summary**:
- 0 Critical risks
- 0 High risks
- 1 Medium risk (FIXED during review)
- 2 Low risks (deferred, acceptable for MVP)

**NFR Assessment**:
- Security: PASS
- Performance: CONCERNS (implementation solid, benchmarks missing)
- Reliability: PASS
- Maintainability: PASS

### Recommended Status

**✓ Ready for Done** - Story implementation is complete and high quality. The one medium-priority issue was fixed during review. Remaining low-priority items are acceptable for MVP and can be addressed in future iterations if needed.

**Justification**:
- All 10 acceptance criteria met (AC 10 partially - implementation complete, benchmarks optional)
- Comprehensive test coverage (14 tests)
- Code quality excellent
- All automated quality checks passing
- Performance issue fixed during review
- Remaining concerns are low priority and acceptable for MVP scope

**Developer Action Required**:
- Update File List to include `apps/server/src/routes/prompts.ts` in Modified section (refactored during QA review)
- Optional: Add performance benchmarks before production deployment
