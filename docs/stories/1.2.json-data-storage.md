# Story 1.2: JSON Data Storage Layer

## Status

Draft

## Story

**As a** developer, **I want** a data abstraction layer that handles reading and
writing task data to a JSON file, **so that** task data persists locally and the
storage backend can be swapped later without changing business logic.

## Acceptance Criteria

1. DataService class created with methods: `loadTasks()`, `saveTasks(tasks)`,
   `ensureDataFileExists()`
2. JSON file location configured at `./data/tasks.json` (relative to project
   root)
3. Data directory automatically created if it doesn't exist on first run
4. JSON schema defined for tasks with TypeScript interface:
   `{ id: string, text: string, createdAt: string, completedAt: string | null, status: 'active' | 'completed' }`
5. `loadTasks()` reads JSON file and parses into Task[] array, returns empty
   array if file doesn't exist
6. `saveTasks()` writes Task[] array to JSON file with proper formatting
   (2-space indentation)
7. Data integrity: File write operations use atomic write pattern (write to temp
   file, then rename) to prevent corruption
8. Error handling: Storage errors throw descriptive exceptions that calling code
   can catch
9. Unit tests verify: loading empty file, loading existing tasks, saving tasks,
   handling corrupted JSON gracefully
10. DataService is a singleton or dependency-injectable to allow mocking in
    tests

## Tasks / Subtasks

- [ ] **Task 1: Create Task type definition in shared package** (AC: 4)
  - [ ] Navigate to `packages/shared/src/types/` directory
  - [ ] Create `Task.ts` with TaskStatus type and Task interface [Source:
        architecture/4-data-models.md#task]
  - [ ] Export TaskStatus as `'active' | 'completed'`
  - [ ] Export Task interface with fields: id (string), text (string), status
        (TaskStatus), createdAt (string), completedAt (string | null)
  - [ ] Create `index.ts` barrel export in types directory
  - [ ] Update `packages/shared/src/index.ts` to export types

- [ ] **Task 2: Create DataService class structure** (AC: 1, 2)
  - [ ] Create `apps/server/src/services/DataService.ts` file
  - [ ] Import Task type from shared package:
        `import type { Task } from '@simple-todo/shared/types'`
  - [ ] Define class with private readonly properties for file paths [Source:
        architecture/8-security-compliance.md#file-system-security]
  - [ ] Set `dataDir` to `path.join(process.cwd(), 'data')`
  - [ ] Set `tasksFilePath` to `path.join(this.dataDir, 'tasks.json')`
  - [ ] Import required Node.js modules: `fs/promises`, `path`

- [ ] **Task 3: Implement ensureDataFileExists method** (AC: 3)
  - [ ] Create async method `ensureDataFileExists(): Promise<void>`
  - [ ] Use `fs.mkdir(this.dataDir, { recursive: true })` to create data
        directory
  - [ ] Check if tasks.json exists using `fs.access()`
  - [ ] If file doesn't exist, create it with empty array: `[]`
  - [ ] Use proper error handling with try/catch

- [ ] **Task 4: Implement loadTasks method** (AC: 5)
  - [ ] Create async method `loadTasks(): Promise<Task[]>`
  - [ ] Call `ensureDataFileExists()` first to ensure file exists
  - [ ] Read file using `fs.readFile(this.tasksFilePath, 'utf-8')`
  - [ ] Parse JSON content and return Task[] array
  - [ ] If file doesn't exist or is empty, return empty array `[]`
  - [ ] Handle corrupted JSON with try/catch, throw descriptive error [Source:
        architecture/8-security-compliance.md#error-handling-information-disclosure]
  - [ ] Add JSDoc comment documenting method behavior

- [ ] **Task 5: Implement saveTasks with atomic write pattern** (AC: 6, 7)
  - [ ] Create async method `saveTasks(tasks: Task[]): Promise<void>`
  - [ ] Define temp file path: `${this.tasksFilePath}.tmp` [Source:
        architecture/8-security-compliance.md#data-integrity-atomic-writes]
  - [ ] Stringify tasks with 2-space indentation:
        `JSON.stringify(tasks, null, 2)`
  - [ ] Write to temp file first:
        `await fs.writeFile(tempFile, content, 'utf-8')`
  - [ ] Perform atomic rename: `await fs.rename(tempFile, this.tasksFilePath)`
  - [ ] Wrap in try/catch, clean up temp file on error
  - [ ] Add JSDoc comment explaining atomic write pattern and crash safety

- [ ] **Task 6: Implement error handling and logging** (AC: 8)
  - [ ] Import Winston logger (configured in Story 1.1) [Source:
        architecture/8-security-compliance.md#logging-monitoring]
  - [ ] Add error logging in catch blocks
  - [ ] Throw descriptive errors: "Failed to load tasks", "Failed to save
        tasks", "Corrupted JSON file"
  - [ ] Include original error message for debugging
  - [ ] Ensure no sensitive information in error messages (no file paths in
        production)

- [ ] **Task 7: Make DataService singleton or injectable** (AC: 10)
  - [ ] Choose pattern: Singleton instance or class with dependency injection
  - [ ] If singleton: export single instance
        `export const dataService = new DataService()`
  - [ ] If injectable: export class for manual instantiation in tests
  - [ ] Add private constructor if using singleton pattern
  - [ ] Document pattern choice in code comments

- [ ] **Task 8: Create unit tests for DataService** (AC: 9)
  - [ ] Create `apps/server/tests/unit/services/DataService.test.ts`
  - [ ] Set up test data directory: `tests/test-data/` for isolated testing
  - [ ] Mock fs module or use real temp directory for tests
  - [ ] Test: `loadTasks()` returns empty array when file doesn't exist
  - [ ] Test: `loadTasks()` parses and returns existing tasks correctly
  - [ ] Test: `saveTasks()` writes tasks to file with correct JSON formatting
  - [ ] Test: `saveTasks()` uses atomic write (verify temp file
        creation/cleanup)
  - [ ] Test: Corrupted JSON throws descriptive error
  - [ ] Test: File write errors are caught and re-thrown with context
  - [ ] Verify test coverage meets 85%+ threshold [Source:
        architecture/10-testing-strategy.md#coverage-requirements]

- [ ] **Task 9: Add integration test for file persistence** (AC: 9)
  - [ ] Create `apps/server/tests/integration/data/DataService.test.ts`
  - [ ] Create temporary test directory in beforeEach hook
  - [ ] Test full round-trip: save tasks, load tasks, verify content matches
  - [ ] Test atomic write prevents corruption: simulate crash during write
  - [ ] Test concurrent operations if applicable (single-user MVP may skip)
  - [ ] Clean up test files in afterEach hook

- [ ] **Task 10: Update .gitignore for data directory** (AC: 2)
  - [ ] Add `/data/` to .gitignore to exclude user data from version control
  - [ ] Add `/data/*.tmp` to ignore temporary files from atomic writes
  - [ ] Verify .gitignore already excludes logs/ directory (from Story 1.1)

## Dev Notes

### Previous Story Context

**Story 1.1: Project Setup and Development Environment**

- Established monorepo structure with `/apps/server`, `/apps/web`,
  `/packages/shared`
- Configured TypeScript with strict mode enabled
- Set up Jest for backend testing
- Created npm workspaces for shared types

**Key Insights:**

- Shared types should be placed in `packages/shared/src/types/` and imported via
  `@simple-todo/shared/types`
- All backend services go in `apps/server/src/services/`
- Tests follow structure: `apps/server/tests/unit/` and
  `apps/server/tests/integration/`

### Data Model: Task Interface

[Source: architecture/4-data-models.md#task]

**TypeScript Interface:**

```typescript
/**
 * Task status type - single source of truth
 */
export type TaskStatus = 'active' | 'completed';

/**
 * Core task entity - minimal, normalized design
 */
export interface Task {
  id: string; // UUID
  text: string; // 1-500 characters
  status: TaskStatus; // 'active' | 'completed'
  createdAt: string; // ISO 8601 timestamp
  completedAt: string | null; // ISO 8601 or null if active
}
```

**Validation Rules:**

- `id`: UUID v4 format (generated by uuid library)
- `text`: 1-500 characters (enforced in TaskService, not DataService)
- `createdAt`: ISO 8601 format (e.g., "2024-01-15T10:30:00.000Z")
- `completedAt`: ISO 8601 format or null for active tasks

**Computed Properties (NOT stored in JSON):**

- `duration`: Calculated from `createdAt` to `completedAt`
- `age`: Calculated from `createdAt` to current time
- These will be computed by TaskHelpers utility (future story)

### DataService Component Specification

[Source: architecture/6-components.md#dataservice]

**Responsibility:** Abstract data persistence layer for JSON file storage with
atomic file operations and data integrity guarantees.

**Key Methods:**

```typescript
class DataService {
  loadTasks(): Promise<Task[]>;
  saveTasks(tasks: Task[]): Promise<void>;
  ensureDataDirectoryExists(): Promise<void>;
  // Future methods (defer to later stories):
  // loadConfig(): Promise<Config>
  // saveConfig(config: Config): Promise<void>
  // loadPromptEvents(): Promise<PromptEvent[]>
  // savePromptEvents(events: PromptEvent[]): Promise<void>
}
```

**For This Story:** Only implement `loadTasks()`, `saveTasks()`, and
`ensureDataDirectoryExists()`. Config and prompt methods will be added in future
stories.

**Dependencies:**

- Node.js `fs/promises` module (filesystem operations)
- No service dependencies (DataService is the lowest layer)

**Technology Stack:**

- TypeScript 5.3+
- Node.js 18+ fs/promises API
- Atomic write pattern (temp file + rename)

### File System Security

[Source: architecture/8-security-compliance.md#file-system-security]

**Fixed File Paths (Security Critical):**

```typescript
class DataService {
  private readonly dataDir = path.join(process.cwd(), 'data');
  private readonly tasksFilePath = path.join(this.dataDir, 'tasks.json');

  // NEVER construct paths from user input
  // ❌ BAD: path.join(this.dataDir, userInput)
  // ✅ GOOD: Hardcoded paths only
}
```

**Protection Against:**

- ✅ **Path Traversal:** No user input in file paths
- ✅ **Directory Traversal:** Fixed directory structure
- ✅ **File Overwrite:** Only write to designated files

**Data Directory Structure:**

```
./data/               # Created at runtime, in .gitignore
├── tasks.json        # Task storage (this story)
├── config.json       # Config storage (future story)
└── prompts.json      # Prompt events (future story)
```

### Atomic Write Pattern (Data Integrity)

[Source: architecture/8-security-compliance.md#data-integrity-atomic-writes]

**Implementation Pattern:**

```typescript
async saveTasks(tasks: Task[]): Promise<void> {
  const tempFile = `${this.tasksFilePath}.tmp`;

  try {
    // Step 1: Write to temporary file first
    await fs.writeFile(tempFile, JSON.stringify(tasks, null, 2), 'utf-8');

    // Step 2: Atomic rename (POSIX guarantees atomicity)
    await fs.rename(tempFile, this.tasksFilePath);

    // If process crashes here, worst case: temp file remains, data file is intact
  } catch (error) {
    // Step 3: Clean up temp file on error
    await fs.unlink(tempFile).catch(() => {});
    throw error;
  }
}
```

**Benefits:**

- ✅ Prevents partial writes/corrupted JSON (NFR6: data integrity)
- ✅ Crash-safe: Either old data or new data, never corrupted state
- ✅ No race conditions (single-user, single-process application)

**Why This Matters:**

- If app crashes during write, JSON file remains valid (either old or new
  version)
- No risk of half-written JSON causing parse errors on next load
- POSIX `rename()` is atomic operation at OS level

### Error Handling Standards

[Source:
architecture/8-security-compliance.md#error-handling-information-disclosure]

**Error Message Guidelines:**

```typescript
// ✅ GOOD: Descriptive but safe error messages
throw new Error('Failed to load tasks: Invalid JSON format');
throw new Error('Failed to save tasks: File system error');

// ❌ BAD: Exposing internal paths in production
throw new Error(`Failed to save /home/user/.../tasks.json`);
```

**Error Handling Pattern:**

```typescript
try {
  const content = await fs.readFile(this.tasksFilePath, 'utf-8');
  return JSON.parse(content);
} catch (error) {
  logger.error('Failed to load tasks', { error });

  if (error instanceof SyntaxError) {
    throw new Error('Failed to load tasks: Corrupted JSON file');
  }

  throw new Error('Failed to load tasks: File system error');
}
```

**Logging Requirements:**

- Use Winston logger for all errors [Source: architecture/3-tech-stack.md]
- Log full error details (including stack) to file
- Return sanitized error messages to calling code
- Never expose file paths or internal details in error messages

### JSON Formatting Standards

[Source: architecture/8-security-compliance.md#data-integrity-atomic-writes]

**Format Requirements:**

- **Indentation:** 2 spaces (consistent with Prettier config)
- **Encoding:** UTF-8
- **Line Endings:** LF (Unix-style)

**Example tasks.json:**

```json
[
  {
    "id": "123e4567-e89b-12d3-a456-426614174000",
    "text": "Buy groceries",
    "status": "active",
    "createdAt": "2024-01-15T10:30:00.000Z",
    "completedAt": null
  },
  {
    "id": "987f6543-e21b-12d3-a456-426614174000",
    "text": "Write documentation",
    "status": "completed",
    "createdAt": "2024-01-14T09:00:00.000Z",
    "completedAt": "2024-01-15T11:45:00.000Z"
  }
]
```

### Singleton vs Dependency Injection Pattern

[Source: architecture/6-components.md#dataservice]

**Option 1: Singleton Pattern (Recommended for MVP)**

```typescript
class DataService {
  private static instance: DataService;

  private constructor() {
    // Private constructor prevents direct instantiation
  }

  static getInstance(): DataService {
    if (!DataService.instance) {
      DataService.instance = new DataService();
    }
    return DataService.instance;
  }
}

export const dataService = DataService.getInstance();
```

**Option 2: Dependency Injection (Better for Testing)**

```typescript
export class DataService {
  constructor() {
    // Public constructor allows instantiation for tests
  }
}

// In production code
const dataService = new DataService();

// In tests
const mockDataService = new DataService();
```

**Recommendation:** Use Option 2 (Dependency Injection) for easier testing.
Services can instantiate their own DataService, and tests can create isolated
instances.

### File Path Management

[Source: architecture/2-high-level-architecture.md#repository-structure]

**File Locations:**

- **DataService class:** `apps/server/src/services/DataService.ts`
- **Task type:** `packages/shared/src/types/Task.ts`
- **Type exports:** `packages/shared/src/types/index.ts`
- **Main export:** `packages/shared/src/index.ts`
- **Unit tests:** `apps/server/tests/unit/services/DataService.test.ts`
- **Integration tests:**
  `apps/server/tests/integration/data/DataService.test.ts`

**Import Paths:**

```typescript
// In DataService.ts
import type { Task } from '@simple-todo/shared/types';
import { promises as fs } from 'fs';
import path from 'path';

// In tests
import { DataService } from '../../../src/services/DataService';
import type { Task } from '@simple-todo/shared/types';
```

### Code Style Considerations

[Source: architecture/13-coding-standards-conventions.md]

**TypeScript Standards:**

- Use `async/await` for all file operations (not callbacks)
- Use explicit return types: `loadTasks(): Promise<Task[]>`
- Use `type` imports for type-only imports
- Enable strict null checks (handle null/undefined explicitly)

**JSDoc Comments:**

```typescript
/**
 * Loads all tasks from the JSON storage file
 *
 * @returns Array of tasks, or empty array if file doesn't exist
 * @throws {Error} If JSON is corrupted or file system error occurs
 *
 * @example
 * const tasks = await dataService.loadTasks();
 * console.log(tasks.length); // Number of tasks
 */
async loadTasks(): Promise<Task[]> {
  // Implementation
}
```

## Dev Notes - Testing

### Testing Framework

[Source: architecture/10-testing-strategy.md#backend-testing-with-jest]

**Backend Testing:** Jest 29.7+ for Node.js/TypeScript

**Test Organization:**

```
apps/server/tests/
├── unit/
│   └── services/
│       └── DataService.test.ts    # Unit tests with mocked fs
├── integration/
│   └── data/
│       └── DataService.test.ts    # Integration tests with real files
├── fixtures/
│   └── tasks.json                 # Sample test data
└── helpers/
    ├── testSetup.ts
    └── factories.ts               # Test data factories
```

### Test Coverage Requirements

[Source: architecture/10-testing-strategy.md#coverage-requirements]

**Minimum Coverage for DataService:** 85%+ (critical data integrity layer)

**Required Test Scenarios:**

1. **loadTasks() - Happy Path:**
   - Load existing tasks from valid JSON file
   - Returns empty array when file doesn't exist
   - Returns empty array when file is empty

2. **loadTasks() - Error Cases:**
   - Throws descriptive error for corrupted JSON
   - Handles file read permission errors

3. **saveTasks() - Happy Path:**
   - Writes tasks to file with correct JSON formatting
   - Uses 2-space indentation
   - Creates data directory if missing

4. **saveTasks() - Atomic Write:**
   - Verify temp file is created first
   - Verify atomic rename occurs
   - Verify temp file is cleaned up on error

5. **ensureDataFileExists():**
   - Creates data directory if missing
   - Creates empty tasks.json if missing
   - Doesn't overwrite existing file

### Test Data Factory Pattern

[Source: architecture/10-testing-strategy.md#test-data-factories]

**Create helper function for test tasks:**

```typescript
// apps/server/tests/helpers/factories.ts
import type { Task, TaskStatus } from '@simple-todo/shared/types';
import { v4 as uuidv4 } from 'uuid';

export function createTestTask(overrides: Partial<Task> = {}): Task {
  return {
    id: uuidv4(),
    text: 'Default test task',
    status: 'active' as TaskStatus,
    createdAt: new Date().toISOString(),
    completedAt: null,
    ...overrides,
  };
}
```

### Integration Testing Strategy

[Source: architecture/10-testing-strategy.md#backend-integration-test]

**Use Real File I/O (Not Mocked):**

```typescript
// Integration test setup
const TEST_DATA_DIR = path.join(__dirname, '../../test-data');

beforeEach(async () => {
  // Create temporary test data directory
  await fs.mkdir(TEST_DATA_DIR, { recursive: true });
});

afterEach(async () => {
  // Clean up test files
  await fs.rm(TEST_DATA_DIR, { recursive: true, force: true });
});
```

**Benefits of Real File Testing:**

- Catches JSON serialization bugs
- Validates file permission handling
- Tests atomic write pattern correctness
- Verifies cross-platform compatibility (Windows/Mac/Linux)

### Testing Commands

[Source: architecture/10-testing-strategy.md#testing-commands]

```bash
# Run all tests
npm test

# Run only DataService tests
npm test -- DataService

# Run with coverage
npm run test:coverage

# Watch mode for development
npm run test:watch
```

## Change Log

| Date       | Version | Description            | Author             |
| ---------- | ------- | ---------------------- | ------------------ |
| 2026-01-20 | 1.0     | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used

_To be filled by Dev Agent_

### Debug Log References

_To be filled by Dev Agent_

### Completion Notes List

_To be filled by Dev Agent_

### File List

_To be filled by Dev Agent_

## QA Results

_To be filled by QA Agent_
